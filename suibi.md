### 内存泄漏
  直接原因: 当不同声明周期的两个东西相互通信时，一生命到期该回收了，却被另一方还持有时，就发生了内存泄露问题
  1. 意外的全局边玲
  2. 遗忘的定时器
     1. 定时器的生命周期并不挂靠在页面上，所以当在当前页面的 js 里通过定时器注册了某个回调函数，而该回调函数内又持有当前页面某个变量或某些 DOM 元素时，就会导致即使页面销毁了，由于定时器持有该页面部分引用而造成页面无法正常被回收，从而导致内存泄漏了
     2. 如果此时再次打开同个页面，内存中其实是有双份页面数据的，如果多次关闭、打开，那么内存泄漏会越来越严重
  3. 使用不当的闭包
     1. 但当函数内再返回一个函数时，由于返回的函数持有外部函数的词法环境，而返回的函数又被其他生命周期东西所持有，导致外部函数虽然执行完了，但内存却无法被回收
  4. 遗漏的DOM元素
     1. DOM 元素的生命周期正常是取决于是否挂载在 DOM 树上，当从 DOM 树上移除时，也就可以被销毁回收了
     2. 但如果某个 DOM 元素，在 js 中也持有它的引用时，那么它的生命周期就由 js 和是否在 DOM 树上两者决定了，记得移除时，两个地方都需要去清理才能正常回收它
  5. 网络回调
     1. 某些场景中，在某个页面发起网络请求，并注册一个回调，且回调函数内持有该页面某些内容，那么，当该页面销毁时，应该注销网络的回调，否则，因为网络持有页面部分内容，也会导致页面部分内容无法被回收

### 跨域方式
   同源策略导致的(协议, 域名, 端口号要相同), 对于二级，三级域名也属于跨域, 但可以配置document.domain来设置共享cookie.
   1. JsonP
     最大特点就是简单实用，但是只支持get请求, 跨域http请求这种情况, 而且存在安全隐患
   2. flash
   3. webscocket
   4. window.postMessage
   5. iframe
   6. Cors 自动添加一些附加头信息，
### 遍历数组
  1. 能用for缓存的方法循环就用for循环，性能最好，写起来繁杂
  2. 不追求极致性能的情况下，建议使用foreach方法，干净简单
  3. 不考虑兼容性的情况下，推荐使用for of方法，最简洁、最直接的遍历数组元素的语法，避开了for-in 循环的所有缺陷与forEach()不同的是，他可以正确响应break，continue和return语句
  4. 避免for in循环尽量避免，太消费性能，太费时间，数组循环不推荐使用

### 渲染十万条数据，如何不卡顿
   1. 用innerHtml插入DOM, 而不是用document.createElement
   2. 用数组来缓存dom字符串，先push进来， 最后子再直接join('')
   3. 插入dom节点，还可以使用克隆技术, 文档断片createDocumentFragment.
   4.
