## [设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)

### UML
 ![uml_class_struct.jpg](./img/uml_class_struct.jpg)

### 六大原则
#### 开闭原则
  对扩展开发，对修改封闭
  一个软件实体如类、模块和函数应该对扩展开发那个、对修改关闭。

  一个类的实现只应该因为错误而修改，新的或者改变的特性应该通过新建不同的类实现。新建的类可以通过继承的方式来重用原类的代码。

#### 单一职责原则
  一个程序只去做好一件事
  如果功能太过复杂就拆开，保持每部分的独立
#### 里氏替换原则
  子类能够覆盖父类
  父类能出现的地方子类就能出现
#### 接口隔离原则
  保持接口的单一独立
  类似单一则指原则，这里更关注接口
#### 依赖倒转原则
  面向接口编程，依赖于抽象而不依赖于具体
  使用方只关注接口而不关注具体类的实现


### 创建型模式
  对象的创建和对象的使用分离。 外界对于这些对象只需要知道他们共同的接口，而不用清除其具体的实现细节，使整个系统的设计更加符合单一职责原则。

#### 简单工厂模式
  又称为静态工厂方法, 类创建型模式
  ```
    if (arg == 'A') {
      return new ConcreteProductA();
    } else if (arg == 'B') {
      return new ConcreteProductB();
    }
  ```
  缺点: 工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑, 这一点与开闭原则是相违背的。
#### 工厂方法模式

#### 抽象工厂模式

#### 建造者模式

#### 原型模式

#### 单例模式


##### 适配器模式
  允许因为接口不兼容而不能在一起工作的类工作在一起。做法是将类自己的接口包裹在一个已存在的类中

##### 装饰器模式
  原有的不能满足现有的需求，对原有的进行增强

##### 代理模式
  同一个类而去调用另一个类的方法，不对这个方法进行直接操作，而用第三方的代理。


### 举例:
  ```
    let checkType = (funciton () {
      let rules = {
        email (str) {
          return 'xxxx';
        },
        mobile(str) {
          return '//';
        }
      };
      return {
        check (str, type) {
          return rules[type] ? rules[type](str): false;
        },
        addRule(type, fn) {
          rules[type] = fn;
        }
      }
    })();

  ```